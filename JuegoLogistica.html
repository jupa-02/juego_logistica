<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Global Trade Master: Cross-Platform Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #05050a;
            font-family: 'Segoe UI', Arial, sans-serif;
            touch-action: none; /* CRITICO: Prevenir zoom/scroll en mÃ³vil */
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * GLOBAL TRADE MASTER WEB - CROSS-PLATFORM EDITION (4.0)
 * ------------------------------------------------------
 * - RESPONSIVE SCALING: Adapts to any screen size/DPR.
 * - MOBILE CONTROLS: "Follow Finger" logic for smooth touch play.
 * - ADAPTIVE UI: Fonts and buttons scale with screen width.
 */

(function() { 

    // --- LIMPIEZA ---
    if (window.gameLoopId) cancelAnimationFrame(window.gameLoopId);
    
    // --- 1. CONFIGURACIÃ“N & ESCALADO ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Variables de Pantalla
    let ANCHO = window.innerWidth;
    let ALTO = window.innerHeight;
    let SCALE = 1; // Factor de escala global
    const REF_WIDTH = 1280; // ResoluciÃ³n base de diseÃ±o

    // FunciÃ³n de redimensionado inteligente
    const onResize = () => {
        ANCHO = window.innerWidth;
        ALTO = window.innerHeight;
        canvas.width = ANCHO;
        canvas.height = ALTO;
        
        // Calculamos escala basada en el ancho, pero limitando para pantallas ultra-wide o ultra-tall
        // En mÃ³viles (portrait), usamos el ancho como referencia principal para que los elementos sean legibles
        SCALE = Math.min(ANCHO / REF_WIDTH, 1.5); 
        if (ANCHO < 600) SCALE = ANCHO / 800; // Ajuste para mÃ³viles vertical
    };
    window.addEventListener('resize', onResize);
    onResize(); // Init

    // Helpers de escalado
    const s = (val) => val * SCALE; // Escalar valor
    const fs = (size) => `bold ${Math.max(12, size * SCALE)}px 'Segoe UI', Arial`; // Fuente escalada

    // --- 2. SISTEMA DE AUDIO ---
    const AudioSys = {
        ctx: null, masterGain: null, buffers: {}, musicSource: null,
        initialized: false, muted: false,

        init: function() {
            if (this.initialized) return;
            const AC = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AC();
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.5; 
            this.masterGain.connect(this.ctx.destination);

            this.buffers.music = this.genMusicBuffer();
            this.buffers.win = this.genWinBuffer();
            this.buffers.lose = this.genLoseBuffer();
            this.buffers.powerup = this.genPowerUpBuffer();

            this.initialized = true;
            if(!this.muted) this.playMusic();
        },

        toggleMute: function() {
            this.muted = !this.muted;
            if (this.ctx) {
                const target = this.muted ? 0 : 0.5;
                this.masterGain.gain.linearRampToValueAtTime(target, this.ctx.currentTime + 0.1);
                if (!this.muted && this.ctx.state === 'suspended') this.ctx.resume();
                if (!this.muted && !this.musicSource) this.playMusic();
            }
        },

        genMusicBuffer: function() {
            const sr = this.ctx.sampleRate; const seconds = 16;
            const buffer = this.ctx.createBuffer(1, sr * seconds, sr);
            const data = buffer.getChannelData(0);
            const notes = [261.63, 311.13, 349.23, 392.00, 466.16];
            for (let i = 0; i < sr * seconds; i++) {
                let t = i / sr; let beat = Math.floor(t * 4);
                let bassFreq = (Math.floor(beat / 4) % 2 === 0) ? 65.41 : 58.27;
                let bass = Math.sin(2 * Math.PI * bassFreq * t) * 0.5 * (1 - ((t*4) % 1));
                let noteIndex = (beat % 5 + Math.floor(beat/8)) % notes.length;
                let note = notes[noteIndex];
                let melody = Math.sin(2 * Math.PI * note * t) * 0.35 * Math.exp(-5 * ((t*4) % 1));
                let hat = (i % Math.floor(sr/8) < 500) ? (Math.random() * 0.2 - 0.1) : 0;
                data[i] = (bass + melody + hat);
            }
            return buffer;
        },
        genWinBuffer: function() {
            const sr = this.ctx.sampleRate; const buffer = this.ctx.createBuffer(1, sr * 0.5, sr);
            const data = buffer.getChannelData(0);
            for(let i=0; i < sr * 0.5; i++) {
                let t = i / sr;
                let val = Math.sin(2 * Math.PI * 880 * t) + 0.5 * Math.sin(2 * Math.PI * 1760 * t);
                data[i] = val * 0.5 * (1 - t/0.5);
            }
            return buffer;
        },
        genLoseBuffer: function() {
            const sr = this.ctx.sampleRate; const buffer = this.ctx.createBuffer(1, sr * 0.4, sr);
            const data = buffer.getChannelData(0);
            for(let i=0; i < sr * 0.4; i++) {
                let t = i / sr;
                let val = (Math.sin(2 * Math.PI * 150 * t) > 0) ? 1.0 : -1.0;
                data[i] = val * 0.3 * (1 - t/0.4);
            }
            return buffer;
        },
        genPowerUpBuffer: function() {
            const sr = this.ctx.sampleRate; const buffer = this.ctx.createBuffer(1, sr * 0.6, sr);
            const data = buffer.getChannelData(0);
            for(let i=0; i < sr * 0.6; i++) {
                let t = i / sr;
                let freq = 400 + (t * 1000); 
                let val = Math.sin(2 * Math.PI * freq * t);
                data[i] = val * 0.3 * (1 - t/0.6);
            }
            return buffer;
        },
        playMusic: function() {
            if (!this.ctx || this.muted) return;
            if (this.musicSource) this.musicSource.stop();
            this.musicSource = this.ctx.createBufferSource();
            this.musicSource.buffer = this.buffers.music;
            this.musicSource.loop = true;
            this.musicSource.connect(this.masterGain);
            this.musicSource.start(0);
        },
        playSfx: function(type) {
            if (!this.ctx || this.muted || !this.buffers[type]) return;
            if (this.ctx.state === 'suspended') this.ctx.resume();
            const src = this.ctx.createBufferSource();
            src.buffer = this.buffers[type];
            src.connect(this.masterGain);
            src.start(0);
        }
    };

    // --- 3. DATOS ---
    const C = {
        SEA_TOP: [0, 100, 160], SEA_BOT: [10, 20, 40],
        CYBER_TOP: [20, 0, 40], CYBER_BOT: [5, 5, 10],
        WHITE: '#FFFFFF', ACCENT_BLUE: '#00BEFF', ACCENT_GREEN: '#2ECC71',
        ACCENT_RED: '#E74C3C', ACCENT_GOLD: '#F1C40F', TEXT_DARK: '#1E2832',
        SHIELD: '#00FFFF', SLOW: '#9B59B6'
    };

    const CONOCIMIENTO = {
        "bienes": {
            "ok": [
                {t:"INCOTERM DDP", d:"Vendedor asume todos los riesgos y costos hasta destino."},
                {t:"CARTA DE CRÃ‰DITO", d:"El cobro estÃ¡ garantizado por el banco contra documentos."},
                {t:"CONVENCIÃ“N VIENA", d:"Marco jurÃ­dico neutral para contratos internacionales."}
            ],
            "fail": [
                {t:"DEMURRAGE", d:"Multa naviera por no liberar el contenedor a tiempo."},
                {t:"FUERZA MAYOR", d:"Evento imprevisible que deja el contrato en el limbo."},
                {t:"ADUANA BLOQUEADA", d:"Falta de Certificado de Origen impide nacionalizar."}
            ]
        },
        "servicios": {
            "ok": [
                {t:"ACUERDO AGCS", d:"Reglas claras de la OMC para comercio de servicios."},
                {t:"MODO 1: DIGITAL", d:"Servicio viaja por la red, nadie se mueve fÃ­sicamente."},
                {t:"PROPIEDAD INTELECTUAL", d:"ProtecciÃ³n de marcas y patentes en el extranjero."}
            ],
            "fail": [
                {t:"DOBLE TRIBUTACIÃ“N", d:"Pagas impuestos en dos paÃ­ses por el mismo ingreso."},
                {t:"BRECHA DE DATOS", d:"Robo de informaciÃ³n confidencial del cliente."},
                {t:"NO HOMOLOGACIÃ“N", d:"Tu licencia profesional no es vÃ¡lida en el destino."}
            ]
        }
    };

    // --- VARIABLES DE ESTADO ---
    let state = "MENU"; 
    let mode = "bienes"; 
    let player; 
    let items = []; 
    let powerups = []; 
    let particles = []; 
    let bgElements = []; 
    let score = 0; 
    let highScore = localStorage.getItem('gtm_highscore') || 0;
    let health = 100; 
    let cardInfo = null; 
    let lastSpawnTime = 0;
    
    // Game Juice
    let shakeStrength = 0;
    let damageFlash = 0;
    let scoreScale = 1.0;
    
    // Ultimate Features
    let combo = 0;
    let comboTimer = 0; 
    let slowMotionTimer = 0; 
    let timeScale = 1.0; 
    
    // Difficulty
    let difficultyLevel = 1;
    let spawnRate = 800; 
    let itemBaseSpeed = 5;

    // --- INPUTS RESPONSIVOS ---
    const keys = { ArrowLeft: false, ArrowRight: false };
    let touchX = null; 
    let isTouching = false; // Nuevo: saber si estÃ¡ arrastrando

    function tryInitAudio() {
        if (!AudioSys.initialized) AudioSys.init();
        else if (AudioSys.ctx && AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();
    }

    const onKeyDown = (e) => {
        tryInitAudio();
        if(keys.hasOwnProperty(e.code)) keys[e.code] = true;
        if(e.code === 'Space') handleInputConfirm();
        if(e.code === 'Escape') togglePause();
    };
    const onKeyUp = (e) => {
        if(keys.hasOwnProperty(e.code)) keys[e.code] = false;
    };

    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);

    // CONTROL TÃCTIL MEJORADO: FOLLOW FINGER
    const handleTouchStart = (e) => {
        e.preventDefault(); // IMPORTANTE: Prevenir scroll
        tryInitAudio();
        const t = e.touches[0];
        checkUIClicks(t.clientX, t.clientY);
        touchX = t.clientX;
        isTouching = true;
    };
    const handleTouchMove = (e) => { 
        e.preventDefault(); 
        touchX = e.touches[0].clientX; 
    };
    const handleTouchEnd = (e) => { 
        e.preventDefault(); 
        isTouching = false; 
        touchX = null; 
    };
    
    // Mouse Support (para PC sin teclado)
    const handleMouseDown = (e) => {
        tryInitAudio();
        checkUIClicks(e.clientX, e.clientY);
        touchX = e.clientX;
        isTouching = true;
    };
    const handleMouseMove = (e) => {
        if (isTouching) touchX = e.clientX;
    }
    const handleMouseUp = () => { 
        isTouching = false; 
        touchX = null; 
    };

    window.addEventListener('touchstart', handleTouchStart, {passive: false});
    window.addEventListener('touchmove', handleTouchMove, {passive: false});
    window.addEventListener('touchend', handleTouchEnd, {passive: false});
    window.addEventListener('mousedown', handleMouseDown);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);

    function checkUIClicks(x, y) {
        // Mute (Top Right)
        if (x > ANCHO - s(80) && y < s(80)) { AudioSys.toggleMute(); return; }

        if (state === "MENU") {
            const btnY = ALTO * 0.6; const btnH = s(80);
            if (y > btnY && y < btnY + btnH) {
                if (x > ANCHO/2 - s(320) && x < ANCHO/2 - s(20)) startGame("bienes");
                if (x > ANCHO/2 + s(20) && x < ANCHO/2 + s(320)) startGame("servicios");
            }
        } else if (state === "PLAY") {
            // Pause (Top Center)
            if (x > ANCHO/2 - s(60) && x < ANCHO/2 + s(60) && y < s(60)) state = "PAUSED";
        } else if (state === "PAUSED") {
            const btnW = s(300); const btnH = s(50);
            // Resume
            if (x > ANCHO/2 - btnW/2 && x < ANCHO/2 + btnW/2 && y > ALTO/2 - s(60) && y < ALTO/2 - s(10)) state = "PLAY";
            // Quit
            if (x > ANCHO/2 - btnW/2 && x < ANCHO/2 + btnW/2 && y > ALTO/2 + s(20) && y < ALTO/2 + s(70)) state = "MENU";
        } else if (state === "INFO" || state === "GAMEOVER") {
            handleInputConfirm();
        }
    }

    function togglePause() {
        if (state === "PLAY") state = "PAUSED";
        else if (state === "PAUSED") state = "PLAY";
    }

    function handleInputConfirm() {
        if (state === "INFO") state = "PLAY";
        else if (state === "GAMEOVER") state = "MENU";
    }

    // --- UTILS ---
    function randomRange(min, max) { return Math.random() * (max - min) + min; }
    function randomInt(min, max) { return Math.floor(Math.random() * (max - min + 1) + min); }
    function drawRoundedRect(x, y, w, h, r, color) {
        ctx.beginPath();
        if (ctx.roundRect) ctx.roundRect(x, y, w, h, r);
        else ctx.rect(x,y,w,h); 
        ctx.fillStyle = color; ctx.fill();
    }
    function drawGradient(topCol, botCol) {
        const grad = ctx.createLinearGradient(0, 0, 0, ALTO);
        grad.addColorStop(0, `rgb(${topCol[0]}, ${topCol[1]}, ${topCol[2]})`);
        grad.addColorStop(1, `rgb(${botCol[0]}, ${botCol[1]}, ${botCol[2]})`);
        ctx.fillStyle = grad; ctx.fillRect(0, 0, ANCHO, ALTO);
    }

    // --- GAME ENTITIES ---
    class Particle {
        constructor(x, y, color, isTrail) {
            this.x = x; this.y = y; this.color = color; this.isTrail = isTrail;
            this.size = randomInt(s(3), s(8)); 
            this.life = isTrail ? 30 : 50; 
            this.maxLife = this.life;
            const spd = s(1);
            if (isTrail) { this.vx = randomRange(-spd*0.5, spd*0.5); this.vy = spd*2; } 
            else { 
                this.vx = randomRange(-spd*5, spd*5); 
                this.vy = randomRange(-spd*5, spd*5); 
                this.gravity = spd*0.2;
            }
        }
        update() { 
            this.x += this.vx * timeScale; 
            this.y += this.vy * timeScale; 
            if(!this.isTrail) this.vy += this.gravity * timeScale;
            this.life--; 
        }
        draw() {
            ctx.save();
            ctx.globalAlpha = this.life / this.maxLife;
            ctx.fillStyle = this.color;
            if (this.isTrail) { ctx.beginPath(); ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2); ctx.fill(); } 
            else { ctx.fillRect(this.x, this.y, this.size, this.size); }
            ctx.restore();
        }
    }

    class FloatingText {
        constructor(x, y, text, color, size = 26) {
            this.x = x; this.y = y; this.text = text; this.color = color;
            this.life = 60; this.maxLife = 60; this.size = size;
        }
        update() { this.y -= s(2) * timeScale; this.life--; }
        draw() {
            ctx.save(); ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
            ctx.fillStyle = this.color; 
            ctx.font = fs(this.size); 
            ctx.textAlign = "center";
            ctx.shadowColor = "black"; ctx.shadowBlur = 4;
            ctx.fillText(this.text, this.x, this.y); ctx.restore();
        }
    }

    class BackgroundElement {
        constructor(mode, layer) { 
            this.mode = mode; this.layer = layer; this.reset(); this.y = randomInt(0, ALTO); 
        }
        reset() {
            this.x = randomInt(0, ANCHO); this.y = -50;
            const baseSpeed = s((this.layer + 1) * 0.5); 
            this.speed = randomRange(baseSpeed, baseSpeed + s(0.5)); 
            this.size = randomInt(s(10 + (this.layer*10)), s(30 + (this.layer*20)));
            this.alpha = randomRange(0.1, 0.3 + (this.layer*0.1));
            this.text = Math.random() > 0.5 ? "1" : "0";
        }
        update() { 
            this.y += this.speed * timeScale; 
            if (this.y > ALTO) this.reset(); 
        }
        draw() {
            ctx.save(); ctx.globalAlpha = this.alpha;
            if (this.mode === 'bienes') {
                ctx.fillStyle = "white"; ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.size, this.size/2, 0, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.fillStyle = this.layer === 2 ? "#00FFC8" : "#005544"; 
                ctx.font = `${s(14 + (this.layer*4))}px monospace`; 
                ctx.fillText(this.text, this.x, this.y);
            }
            ctx.restore();
        }
    }

    class PowerUp {
        constructor() {
            this.type = Math.random() > 0.5 ? 'shield' : 'slow';
            this.x = randomInt(s(50), ANCHO - s(50));
            this.y = -s(60);
            this.speed = s(4);
            this.w = s(50); this.h = s(50);
            this.angle = 0;
        }
        update() {
            this.y += this.speed * timeScale;
            this.angle += 0.05;
        }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y);
            ctx.shadowColor = this.type === 'shield' ? C.SHIELD : C.SLOW;
            ctx.shadowBlur = 20;
            ctx.fillStyle = this.type === 'shield' ? C.SHIELD : C.SLOW;
            ctx.translate(0, Math.sin(Date.now()*0.005)*5);
            
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                ctx.lineTo(this.w/2 * Math.cos(this.angle + i * Math.PI / 3), this.w/2 * Math.sin(this.angle + i * Math.PI / 3));
            }
            ctx.fill();
            
            ctx.shadowBlur = 0; ctx.fillStyle = "#000";
            ctx.font = fs(20); ctx.textAlign = "center";
            ctx.fillText(this.type === 'shield' ? "ðŸ›¡ï¸" : "â³", 0, s(8));
            ctx.restore();
        }
        getRect() { return {x: this.x-this.w/2, y: this.y-this.h/2, w: this.w, h: this.h}; }
    }

    class Player {
        constructor(mode) {
            this.mode = mode; 
            this.w = s(80); this.h = s(100);
            this.x = ANCHO / 2; this.y = ALTO - s(150); 
            this.targetX = this.x;
            this.angle = 0; this.floatTimer = 0; this.offsetY = 0;
            this.hasShield = false;
        }
        update() {
            // Teclado
            let dir = 0;
            if (keys.ArrowLeft) dir = -1; if (keys.ArrowRight) dir = 1;
            
            // Movimiento hÃ­brido:
            // Si hay teclado, usamos velocidad constante.
            // Si hay touch, usamos posiciÃ³n absoluta (mÃ¡s preciso en mÃ³vil).
            
            if (dir !== 0) {
                this.targetX += dir * s(12);
            } else if (isTouching && touchX !== null) {
                // FOLLOW FINGER MODE
                // Si estamos en pausa (centro arriba), no mover
                if (!(touchX > ANCHO/2 - s(60) && touchX < ANCHO/2 + s(60) && state === "PLAY" && false)) {
                     // Interpolamos targetX hacia touchX
                     this.targetX = touchX;
                }
            }
            
            this.targetX = Math.max(s(50), Math.min(ANCHO - s(50), this.targetX));
            
            // Suavizado
            const diff = this.targetX - this.x; 
            this.x += diff * 0.15; 
            
            this.angle += ((-diff * 0.05 * (Math.PI / 180)) - this.angle) * 0.1;
            this.floatTimer += 0.1; this.offsetY = Math.sin(this.floatTimer) * s(5);
        }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y + this.offsetY); 
            
            if (this.hasShield) {
                ctx.save(); ctx.strokeStyle = C.SHIELD; ctx.lineWidth = s(3);
                ctx.globalAlpha = 0.6 + Math.sin(Date.now() * 0.01) * 0.2;
                ctx.beginPath(); ctx.arc(0, 0, s(60), 0, Math.PI*2); ctx.stroke();
                ctx.fillStyle = "rgba(0, 255, 255, 0.1)"; ctx.fill(); ctx.restore();
            }

            ctx.rotate(this.angle);
            const W = s(30); const H = s(40);
            if (this.mode === 'bienes') {
                ctx.fillStyle = C.WHITE; ctx.beginPath();
                ctx.moveTo(-W, 0); ctx.lineTo(W, 0); ctx.lineTo(W*0.66, H); ctx.lineTo(-W*0.66, H); ctx.fill();
                ctx.fillStyle = "#3498DB"; ctx.fillRect(-W*0.8, H*0.75, W*1.6, s(5));
                const boxW = s(14); const boxH = s(25);
                [C.ACCENT_RED, C.ACCENT_GOLD, C.ACCENT_GREEN].forEach((c, i) => {
                    ctx.fillStyle = c; ctx.fillRect(-s(25) + (i*s(18)), -s(25), boxW, boxH);
                });
            } else {
                drawRoundedRect(-s(25), -s(20), s(50), s(40), s(10), C.ACCENT_BLUE);
                ctx.strokeStyle = C.WHITE; ctx.lineWidth = s(3); ctx.beginPath(); ctx.arc(0, -s(10), s(15), 0, Math.PI*2); ctx.stroke();
                ctx.fillStyle = C.WHITE; ctx.beginPath(); ctx.arc(0, -s(10), s(12), 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = C.ACCENT_BLUE; ctx.lineWidth = s(2);
                ctx.beginPath(); ctx.arc(0, -s(10), s(6), -Math.PI/2 - 0.5, -Math.PI/2 + 0.5); ctx.stroke();
            }
            ctx.restore();
        }
        getRect() { return { x: this.x - this.w/2, y: this.y + this.offsetY - this.h/2, w: this.w, h: this.h }; }
    }

    class Item {
        constructor(mode, speedMult) {
            this.mode = mode; this.isGood = Math.random() > 0.4;
            this.w = s(60); this.h = s(60); 
            this.x = randomInt(s(50), ANCHO - s(50)); this.y = -s(70); 
            this.speed = s(itemBaseSpeed) * speedMult;
        }
        update() { 
            this.y += this.speed * timeScale; 
            this.x += Math.sin(Date.now() * 0.005) * s(1.5); 
        }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y);
            ctx.fillStyle = "rgba(0,0,0,0.2)"; ctx.beginPath(); ctx.ellipse(0, s(35), s(20), s(5), 0, 0, Math.PI*2); ctx.fill();
            if (this.isGood) {
                drawRoundedRect(-s(20), -s(25), s(40), s(50), s(5), "#ECF0F1");
                ctx.fillStyle = C.ACCENT_GREEN; ctx.beginPath(); ctx.arc(0, 0, s(15), 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = C.WHITE; ctx.font = fs(20); ctx.textAlign = "center"; ctx.fillText("$", 0, s(7));
            } else {
                ctx.fillStyle = C.ACCENT_RED; ctx.beginPath(); ctx.moveTo(0, -s(30)); ctx.lineTo(s(30), s(25)); ctx.lineTo(-s(30), s(25)); ctx.fill();
                ctx.fillStyle = C.WHITE; ctx.font = fs(20); ctx.textAlign = "center"; ctx.fillText("!", 0, s(15));
            }
            ctx.restore();
        }
        getRect() { return { x: this.x - this.w/2, y: this.y - this.h/2, w: this.w, h: this.h }; }
    }

    // --- LOGIC ---

    for(let i=0; i<30; i++) bgElements.push(new BackgroundElement('bienes', i%3));

    function startGame(selectedMode) {
        mode = selectedMode; state = "PLAY"; score = 0; health = 100;
        player = new Player(mode); 
        items = []; powerups = []; particles = []; 
        bgElements = [];
        for(let i=0; i<30; i++) bgElements.push(new BackgroundElement(mode, i%3));
        difficultyLevel = 1; spawnRate = 800; itemBaseSpeed = 5;
        combo = 0; comboTimer = 0; slowMotionTimer = 0; timeScale = 1.0;
        tryInitAudio();
    }

    function triggerShake(strength) { shakeStrength = strength; }
    function triggerDamageFlash() { damageFlash = 1.0; }

    function updateDifficulty() {
        let newLevel = Math.floor(score / 5000) + 1;
        if (newLevel > difficultyLevel) {
            difficultyLevel = newLevel;
            spawnRate = Math.max(300, 800 - (difficultyLevel * 50)); 
            itemBaseSpeed = Math.min(12, 5 + (difficultyLevel * 0.5));
            particles.push(new FloatingText(ANCHO/2, ALTO/2, "Â¡LEVEL UP!", "#FFFFFF", 50));
        }
    }

    function checkCollision(r1, r2) {
        return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y);
    }

    function saveHighScore() {
        if (score > highScore) { highScore = score; localStorage.setItem('gtm_highscore', highScore); }
    }

    function activateSlowMotion() {
        slowMotionTimer = 300; 
        timeScale = 0.3;
    }

    function gameLoop(timestamp) {
        if (slowMotionTimer > 0) {
            slowMotionTimer--;
            if (slowMotionTimer <= 0) timeScale = 1.0;
        }

        bgElements.forEach(b => b.update());

        if (state === "PLAY") {
            player.update();
            updateDifficulty();

            if (timestamp - lastSpawnTime > spawnRate / timeScale) { 
                items.push(new Item(mode, 1 + (difficultyLevel * 0.05))); 
                if (Math.random() < 0.05) powerups.push(new PowerUp());
                lastSpawnTime = timestamp; 
            }
            
            if (Math.random() > 0.6) {
                const col = mode === 'bienes' ? C.WHITE : C.ACCENT_BLUE;
                particles.push(new Particle(player.x, player.y + s(35), col, true));
            }

            for (let i = powerups.length - 1; i >= 0; i--) {
                let p = powerups[i]; p.update();
                if (checkCollision(player.getRect(), p.getRect())) {
                    if (p.type === 'shield') {
                        player.hasShield = true;
                        particles.push(new FloatingText(player.x, player.y - s(80), "Â¡ESCUDO!", C.SHIELD));
                    } else {
                        activateSlowMotion();
                        particles.push(new FloatingText(player.x, player.y - s(80), "Â¡SLOW MOTION!", C.SLOW));
                    }
                    AudioSys.playSfx('powerup'); powerups.splice(i, 1);
                } else if (p.y > ALTO) powerups.splice(i, 1);
            }

            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i]; item.update();
                if (checkCollision(player.getRect(), item.getRect())) {
                    if (item.isGood) {
                        combo++; comboTimer = 20;
                        let multiplier = 1 + (combo * 0.1);
                        let pts = Math.floor(2000 * multiplier);
                        score += pts; scoreScale = 1.5;
                        particles.push(new FloatingText(player.x, player.y - s(50), `+$${pts.toLocaleString()}`, C.ACCENT_GOLD));
                        if(combo > 1) particles.push(new FloatingText(player.x, player.y - s(80), `${combo}x COMBO`, "#FFA500", 20));
                        for(let k=0; k<15; k++) particles.push(new Particle(item.x, item.y, C.ACCENT_GOLD, false));
                        AudioSys.playSfx('win');
                        
                        const dbKey = "ok";
                        const dataList = CONOCIMIENTO[mode][dbKey];
                        const data = dataList[Math.floor(Math.random() * dataList.length)];
                        cardInfo = { t: data.t, d: data.d, ok: true };
                        // En mÃ³vil a veces es molesto parar a cada rato. Haremos que INFO sea menos intrusivo o solo en hit?
                        // Por ahora igual:
                        state = "INFO";
                    } else {
                        if (player.hasShield) {
                            player.hasShield = false;
                            particles.push(new FloatingText(player.x, player.y - s(50), "Â¡BLOQUEADO!", C.SHIELD));
                            AudioSys.playSfx('powerup'); 
                        } else {
                            health -= 25; combo = 0; triggerShake(15); triggerDamageFlash(); 
                            for(let k=0; k<20; k++) particles.push(new Particle(item.x, item.y, C.ACCENT_RED, false));
                            AudioSys.playSfx('lose');
                            const dbKey = "fail";
                            const dataList = CONOCIMIENTO[mode][dbKey];
                            const data = dataList[Math.floor(Math.random() * dataList.length)];
                            cardInfo = { t: data.t, d: data.d, ok: false };
                            state = "INFO";
                        }
                    }
                    items.splice(i, 1); 
                    if (health <= 0) { state = "GAMEOVER"; saveHighScore(); }
                    continue; 
                }
                if (item.y > ALTO) items.splice(i, 1);
            }
        }
        
        particles.forEach((p, i) => { p.update(); if (p.life <= 0) particles.splice(i, 1); });
        
        if (shakeStrength > 0) shakeStrength *= 0.9;
        if (damageFlash > 0) damageFlash -= 0.05;
        if (scoreScale > 1.0) scoreScale -= 0.03;
        if (comboTimer > 0) comboTimer--;

        // --- DRAWING ---
        ctx.save();
        if (shakeStrength > 0) {
            ctx.translate((Math.random() - 0.5) * shakeStrength, (Math.random() - 0.5) * shakeStrength);
        }

        const cols = mode === 'bienes' ? [C.SEA_TOP, C.SEA_BOT] : [C.CYBER_TOP, C.CYBER_BOT];
        drawGradient(cols[0], cols[1]);
        bgElements.forEach(b => b.draw());

        if (state === "MENU") {
            ctx.fillStyle = C.WHITE; ctx.font = fs(60); ctx.textAlign = "center";
            ctx.shadowColor = C.SHADOW; ctx.shadowBlur = 10;
            ctx.fillText("GLOBAL TRADE MASTER", ANCHO/2, ALTO*0.25);
            ctx.fillStyle = C.ACCENT_GOLD; ctx.font = fs(30); ctx.fillText("ULTIMATE EDITION", ANCHO/2, ALTO*0.32);
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = "#AAA"; ctx.font = fs(24);
            ctx.fillText(`ðŸ† RÃ‰CORD: $${parseInt(highScore).toLocaleString()}`, ANCHO/2, ALTO*0.4);

            const btnY = ALTO * 0.6; const btnW = s(300); const btnH = s(80); const gap = s(40);
            
            // Botones responsivos (verticales en movil si es muy estrecho, horizontales en PC)
            let bx1, bx2, by1, by2;
            if (ANCHO > 600) {
                 bx1 = ANCHO/2 - btnW - gap/2; by1 = btnY;
                 bx2 = ANCHO/2 + gap/2; by2 = btnY;
            } else {
                 bx1 = ANCHO/2 - btnW/2; by1 = btnY;
                 bx2 = ANCHO/2 - btnW/2; by2 = btnY + btnH + s(20);
            }

            drawRoundedRect(bx1, by1, btnW, btnH, s(15), C.ACCENT_BLUE);
            ctx.fillStyle = C.WHITE; ctx.font = fs(30); ctx.fillText("BIENES", bx1 + btnW/2, by1 + btnH*0.6);
            drawRoundedRect(bx2, by2, btnW, btnH, s(15), C.ACCENT_GREEN);
            ctx.fillStyle = C.WHITE; ctx.fillText("SERVICIOS", bx2 + btnW/2, by2 + btnH*0.6);
            
        } 
        else if (state === "PLAY" || state === "INFO" || state === "PAUSED") {
            particles.forEach(p => p.draw()); 
            powerups.forEach(p => p.draw());
            items.forEach(i => i.draw()); 
            player.draw();

            if (damageFlash > 0) {
                ctx.fillStyle = `rgba(255, 0, 0, ${damageFlash * 0.3})`;
                ctx.fillRect(0, 0, ANCHO, ALTO);
            }
            
            if (timeScale < 1.0) {
                const grad = ctx.createRadialGradient(ANCHO/2, ALTO/2, ALTO/4, ANCHO/2, ALTO/2, ALTO);
                grad.addColorStop(0, "rgba(155, 89, 182, 0)");
                grad.addColorStop(1, "rgba(155, 89, 182, 0.3)");
                ctx.fillStyle = grad; ctx.fillRect(0,0,ANCHO,ALTO);
                ctx.fillStyle = C.SLOW; ctx.font = fs(20); ctx.textAlign = "center";
                ctx.fillText("â³ TIEMPO RALENTIZADO", ANCHO/2, ALTO - s(100));
            }

            // HUD
            ctx.fillStyle = C.WHITE; ctx.fillRect(0, 0, ANCHO, s(70));
            ctx.fillStyle = "#DDDDDD"; ctx.fillRect(0, s(68), ANCHO, 2);
            
            ctx.save(); ctx.translate(s(30), s(45)); ctx.scale(scoreScale, scoreScale);
            ctx.textAlign = "left"; ctx.font = fs(40); ctx.fillStyle = C.ACCENT_GOLD;
            ctx.fillText(`$${score.toLocaleString()}`, 0, 0); ctx.restore();

            if (combo > 1) {
                const cSize = s(30 + (comboTimer > 0 ? 10 : 0));
                ctx.font = `bold ${cSize}px Arial`;
                ctx.fillStyle = combo > 5 ? "#FF4500" : "#FFA500";
                ctx.textAlign = "left"; ctx.fillText(`ðŸ”¥ ${combo}x`, s(250), s(45));
            }

            const barW = Math.min(s(300), ANCHO * 0.3); 
            ctx.fillStyle = "#E6E6E6"; drawRoundedRect(ANCHO - barW - s(30), s(20), barW, s(30), s(10), "#E6E6E6");
            if (health > 0) drawRoundedRect(ANCHO - barW - s(30), s(20), (health/100)*barW, s(30), s(10), C.ACCENT_GREEN);
            
            ctx.fillStyle = "#95A5A6"; ctx.font = fs(14); ctx.textAlign = "right";
            ctx.fillText(`NIVEL ${difficultyLevel}`, ANCHO - barW - s(40), s(40));

            const btnW = s(120); const btnH = s(40); 
            const btnX = ANCHO/2 - btnW/2; const btnY = s(15);
            drawRoundedRect(btnX, btnY, btnW, btnH, s(10), "#34495E");
            ctx.fillStyle = C.WHITE; ctx.font = fs(20); ctx.textAlign = "center";
            ctx.fillText("PAUSA", ANCHO/2, btnY + btnH*0.7);

            if (state === "INFO") {
                ctx.fillStyle = "rgba(10, 15, 30, 0.9)"; ctx.fillRect(0, 0, ANCHO, ALTO);
                const cw = Math.min(s(800), ANCHO - s(40)); 
                // Ajustar altura tarjeta si el texto es largo o pantalla pequeÃ±a
                const ch = s(450); 
                const cx = (ANCHO - cw) / 2; const cy = (ALTO - ch) / 2;
                
                drawRoundedRect(cx, cy, cw, ch, s(20), C.WHITE);
                const col = cardInfo.ok ? C.ACCENT_GREEN : C.ACCENT_RED;
                drawRoundedRect(cx, cy, cw, s(80), s(20), col); ctx.fillRect(cx, cy+s(40), cw, s(40)); 
                
                ctx.textAlign = "center"; ctx.fillStyle = C.WHITE; ctx.font = fs(30);
                // Texto wrap para titulo
                ctx.fillText(cardInfo.ok ? "Â¡CONOCIMIENTO!" : "Â¡RIESGO!", ANCHO/2, cy + s(50));
                
                ctx.fillStyle = C.TEXT_DARK; ctx.font = fs(35); ctx.fillText(cardInfo.t, ANCHO/2, cy + s(130));
                ctx.fillStyle = "#50505A"; ctx.font = fs(24);
                
                // Word Wrap Manual
                const words = cardInfo.d.split(" "); let line = ""; let ly = cy + s(190);
                for(let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + " "; const metrics = ctx.measureText(testLine);
                    if (metrics.width > cw - s(80) && n > 0) { ctx.fillText(line, ANCHO/2, ly); line = words[n] + " "; ly += s(35); } 
                    else { line = testLine; }
                }
                ctx.fillText(line, ANCHO/2, ly);
                
                ctx.fillStyle = col; ctx.font = fs(20); 
                ctx.fillText("TOCA PARA CONTINUAR", ANCHO/2, cy + ch - s(40));
            }

            if (state === "PAUSED") {
                ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.fillRect(0,0,ANCHO, ALTO);
                const pmW = Math.min(s(400), ANCHO-40); const pmH = s(300); 
                const pmX = (ANCHO-pmW)/2; const pmY = (ALTO-pmH)/2;
                drawRoundedRect(pmX, pmY, pmW, pmH, s(20), C.WHITE);
                ctx.fillStyle = C.TEXT_DARK; ctx.font = fs(40); ctx.textAlign = "center";
                ctx.fillText("PAUSA", ANCHO/2, pmY + s(60));
                
                const bW = Math.min(s(300), pmW - 40);
                const bH = s(50);
                
                drawRoundedRect(ANCHO/2 - bW/2, ALTO/2 - s(30), bW, bH, s(10), C.ACCENT_GREEN);
                ctx.fillStyle = C.WHITE; ctx.font = fs(24); ctx.fillText("CONTINUAR", ANCHO/2, ALTO/2 + s(5));
                
                drawRoundedRect(ANCHO/2 - bW/2, ALTO/2 + s(40), bW, bH, s(10), C.ACCENT_RED);
                ctx.fillStyle = C.WHITE; ctx.fillText("SALIR", ANCHO/2, ALTO/2 + s(75));
            }
        }
        else if (state === "GAMEOVER") {
            ctx.fillStyle = "rgba(0,0,0,0.9)"; ctx.fillRect(0,0, ANCHO, ALTO);
            ctx.textAlign = "center"; ctx.fillStyle = C.WHITE; ctx.font = fs(60);
            ctx.fillText("FIN DE PARTIDA", ANCHO/2, ALTO/2 - s(50));
            ctx.fillStyle = C.ACCENT_GOLD; ctx.font = fs(40); ctx.fillText(`Total: $${score.toLocaleString()}`, ANCHO/2, ALTO/2 + s(20));
            ctx.fillStyle = C.WHITE; ctx.font = fs(20); ctx.fillText("Toca para volver al menÃº", ANCHO/2, ALTO/2 + s(80));
        }

        ctx.restore(); 

        const muteCol = AudioSys.muted ? C.ACCENT_RED : "#95A5A6";
        drawRoundedRect(ANCHO - s(60), s(20), s(40), s(40), s(10), muteCol);
        ctx.fillStyle = C.WHITE; ctx.font = fs(20); ctx.textAlign = "center";
        ctx.fillText(AudioSys.muted ? "ðŸ”‡" : "ðŸ”Š", ANCHO - s(40), s(47));

        window.gameLoopId = requestAnimationFrame(gameLoop);
    }

    window.gameLoopId = requestAnimationFrame(gameLoop);

})(); 
</script>
</body>
</html>
